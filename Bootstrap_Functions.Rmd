---
title: "Bootstrap_Functions"
author: "R. Travis Merrill"
date: "2022-12-24"
output: html_document
---

```{r setup, include=FALSE, echo=FALSE}
library(dplyr)
library(gt)
library(knitr)
opts_chunk$set(echo = TRUE)
```

## Distribution Functions 

```{r}
#Inverse cumulative distribution function.
#Returns the value of a desired percentile from a given dataset. 
icdf = function(data,a){
  if(a <= 0.5){
    i = floor(a*(length(data)+1))
  }else{
    i = (length(data)+1) - floor((1-a)*(length(data)+1))
  }
  data = sort(data)
  return(data[i])
}
```

```{r}
#Cumulative Distribution Function.
#This reports the proportion of values that are less than or equal to a given value.
cdf = function(data,a){
  data = sort(data)
  vec = which(data <= a)
  b = (length(vec)/length(data))
  return(b)
}
```

##Estimating the population distribution when considering population size. 
<br>

#Large population: Generally N/n > 20, we sample *with* replacement from a *single* copy of the sample
```{r}

#data - a data frame
#n - the sample size 
#b- the number of bootstrap iterations, typically 1000+
#This particular function draws a series of *b* random samples of size *n* from the original sample data and
#Determines the median of each RS. This develops the bootstrap distribution of the population median.
#This function reports the mean of this distribution, which provides a statistically sound estimate of the unknown population median. 
#We also report the standard error of the distribution, the bias of the estimator, and Normal, Symetrric, and Non-Symetric confidence intervals of the estimate. 

data = data;

bootmedplus = function(data,n,b){
  BTmedian = rep(0,b);
  for (i in 1:b) {
  BTsamp = sample(data, n, replace = T)
  BTmedian[i] = icdf(BTsamp,0.5)
  };
  BTmedian = sort(BTmedian);
  Bbtmedmean = mean(BTmedian);
  BbtSE = sqrt((1/(b-1))*sum((BTmedian - mean(BTmedian))**2))
  #Normal population distribution
  NormalCI = c(icdf(data,0.5)-BbtSE*1.645, icdf(data,0.5) + BbtSE*1.645)
  #Symmetric population distribution 
  SCI = c(BTmedian[0.05*b], BTmedian[0.95*b + 1])
  #Non-symmetric (no assumption) on pop distribution 
  NSCI = c(2*icdf(data,0.5) - BTmedian[0.95*b + 1], 2*icdf(data,0.5) - BTmedian[0.05*b])
  bias = mean(BTmedian) - icdf(data,0.5)
  output = list("SE" = BbtSE,"bias" = bias,"NormalCI" = NormalCI,"SCI" = SCI,"NSCI" = NSCI)
  return(output)
}
```

##Small population with N/n = a < 20 and an *integer*. We sample *without* replacement from *a* copies of the sample. 
```{r}
data = rep(data, a)

#This particular function estimates the IQR from multivariate data sets.
#It holds each observation's combination of covariates as it samples. 
#n and b are interpreted as before.

bootIQR = function(data,n,b){
  bootiqr = rep(0,b)
  for (i in 1:b) {
  samp = data[sample(seq_len(nrow(data)),n,replace = TRUE),]
  bootiqr[i] = icdf(samp[,1],0.75)-icdf(samp[,1],0.25)
  }
  return(bootiqr)
}

```

